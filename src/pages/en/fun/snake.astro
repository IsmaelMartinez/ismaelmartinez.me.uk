---
import Layout from '../../../layouts/Layout.astro';
import { useTranslations, getLocalizedPath } from '../../../i18n/translations';

const lang = 'en';
const t = useTranslations(lang);
---

<Layout title="Snake Game" lang={lang}>
  <section class="snake-section">
    <div class="container">
      <a href={getLocalizedPath('/fun', lang)} class="back-link">‚Üê {t('fun.backToFun')}</a>

      <div class="game-container">
        <div class="game-header">
          <h1><span class="snake-emoji">üêç</span> {t('fun.snake.title')}</h1>
          <div class="scores">
            <div class="score-item">
              <span class="score-label">{t('fun.snake.score')}</span>
              <span id="score" class="score-value">0</span>
            </div>
            <div class="score-item">
              <span class="score-label">{t('fun.snake.highScore')}</span>
              <span id="high-score" class="score-value">0</span>
            </div>
          </div>
        </div>

        <div class="game-area">
          <canvas id="game-canvas"></canvas>
          <div id="game-overlay" class="game-overlay">
            <div class="overlay-content">
              <span class="play-icon">‚ñ∂</span>
              <p>{t('fun.snake.instructions')}</p>
              <button id="start-btn" class="btn btn-primary btn-large">{t('fun.snake.play')}</button>
            </div>
          </div>
          <div id="game-over-overlay" class="game-overlay game-over" style="display: none;">
            <div class="overlay-content">
              <span class="game-over-emoji">üíÄ</span>
              <h2>{t('fun.snake.gameOver')}</h2>
              <p class="final-score">{t('fun.snake.score')}: <span id="final-score">0</span></p>
              <button id="restart-btn" class="btn btn-primary btn-large">{t('fun.snake.playAgain')}</button>
            </div>
          </div>
        </div>

        <div class="mobile-controls">
          <button class="control-btn" data-dir="up">‚Üë</button>
          <div class="control-row">
            <button class="control-btn" data-dir="left">‚Üê</button>
            <button class="control-btn" data-dir="down">‚Üì</button>
            <button class="control-btn" data-dir="right">‚Üí</button>
          </div>
        </div>
      </div>
    </div>
  </section>
</Layout>

<script>
  const canvas = document.getElementById('game-canvas') as HTMLCanvasElement;
  const ctx = canvas.getContext('2d')!;
  const overlay = document.getElementById('game-overlay')!;
  const gameOverOverlay = document.getElementById('game-over-overlay')!;
  const startBtn = document.getElementById('start-btn')!;
  const restartBtn = document.getElementById('restart-btn')!;
  const scoreEl = document.getElementById('score')!;
  const highScoreEl = document.getElementById('high-score')!;
  const finalScoreEl = document.getElementById('final-score')!;

  const GRID_SIZE = 20;
  const CANVAS_SIZE = 400;

  canvas.width = CANVAS_SIZE;
  canvas.height = CANVAS_SIZE;

  let snake: { x: number; y: number }[] = [];
  let food: { x: number; y: number } = { x: 0, y: 0 };
  let direction: { x: number; y: number } = { x: 1, y: 0 };
  let nextDirection: { x: number; y: number } = { x: 1, y: 0 };
  let score = 0;
  let highScore = parseInt(localStorage.getItem('snake-high-score') || '0');
  let gameLoop: ReturnType<typeof setInterval> | null = null;
  let gameSpeed = 150;

  highScoreEl.textContent = highScore.toString();

  function initGame() {
    snake = [
      { x: 10, y: 10 },
      { x: 9, y: 10 },
      { x: 8, y: 10 }
    ];
    direction = { x: 1, y: 0 };
    nextDirection = { x: 1, y: 0 };
    score = 0;
    gameSpeed = 150;
    scoreEl.textContent = '0';
    spawnFood();
  }

  function spawnFood() {
    do {
      food = {
        x: Math.floor(Math.random() * (CANVAS_SIZE / GRID_SIZE)),
        y: Math.floor(Math.random() * (CANVAS_SIZE / GRID_SIZE))
      };
    } while (snake.some(seg => seg.x === food.x && seg.y === food.y));
  }

  function draw() {
    // Clear canvas
    ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--color-bg-secondary').trim() || '#1a1a1a';
    ctx.fillRect(0, 0, CANVAS_SIZE, CANVAS_SIZE);

    // Draw grid
    ctx.strokeStyle = getComputedStyle(document.documentElement).getPropertyValue('--color-border').trim() || '#262626';
    ctx.lineWidth = 0.5;
    for (let i = 0; i <= CANVAS_SIZE; i += GRID_SIZE) {
      ctx.beginPath();
      ctx.moveTo(i, 0);
      ctx.lineTo(i, CANVAS_SIZE);
      ctx.stroke();
      ctx.beginPath();
      ctx.moveTo(0, i);
      ctx.lineTo(CANVAS_SIZE, i);
      ctx.stroke();
    }

    // Draw food
    ctx.fillStyle = '#ef4444';
    ctx.beginPath();
    ctx.arc(
      food.x * GRID_SIZE + GRID_SIZE / 2,
      food.y * GRID_SIZE + GRID_SIZE / 2,
      GRID_SIZE / 2 - 2,
      0,
      Math.PI * 2
    );
    ctx.fill();

    // Draw snake
    snake.forEach((segment, index) => {
      const gradient = ctx.createRadialGradient(
        segment.x * GRID_SIZE + GRID_SIZE / 2,
        segment.y * GRID_SIZE + GRID_SIZE / 2,
        0,
        segment.x * GRID_SIZE + GRID_SIZE / 2,
        segment.y * GRID_SIZE + GRID_SIZE / 2,
        GRID_SIZE / 2
      );

      if (index === 0) {
        gradient.addColorStop(0, '#4ade80');
        gradient.addColorStop(1, '#22c55e');
      } else {
        gradient.addColorStop(0, '#22c55e');
        gradient.addColorStop(1, '#16a34a');
      }

      ctx.fillStyle = gradient;
      ctx.beginPath();
      ctx.roundRect(
        segment.x * GRID_SIZE + 1,
        segment.y * GRID_SIZE + 1,
        GRID_SIZE - 2,
        GRID_SIZE - 2,
        4
      );
      ctx.fill();

      // Draw eyes on head
      if (index === 0) {
        ctx.fillStyle = '#000';
        const eyeSize = 3;
        const eyeOffset = 5;

        if (direction.x === 1) {
          ctx.beginPath();
          ctx.arc(segment.x * GRID_SIZE + GRID_SIZE - eyeOffset, segment.y * GRID_SIZE + eyeOffset, eyeSize, 0, Math.PI * 2);
          ctx.arc(segment.x * GRID_SIZE + GRID_SIZE - eyeOffset, segment.y * GRID_SIZE + GRID_SIZE - eyeOffset, eyeSize, 0, Math.PI * 2);
          ctx.fill();
        } else if (direction.x === -1) {
          ctx.beginPath();
          ctx.arc(segment.x * GRID_SIZE + eyeOffset, segment.y * GRID_SIZE + eyeOffset, eyeSize, 0, Math.PI * 2);
          ctx.arc(segment.x * GRID_SIZE + eyeOffset, segment.y * GRID_SIZE + GRID_SIZE - eyeOffset, eyeSize, 0, Math.PI * 2);
          ctx.fill();
        } else if (direction.y === -1) {
          ctx.beginPath();
          ctx.arc(segment.x * GRID_SIZE + eyeOffset, segment.y * GRID_SIZE + eyeOffset, eyeSize, 0, Math.PI * 2);
          ctx.arc(segment.x * GRID_SIZE + GRID_SIZE - eyeOffset, segment.y * GRID_SIZE + eyeOffset, eyeSize, 0, Math.PI * 2);
          ctx.fill();
        } else {
          ctx.beginPath();
          ctx.arc(segment.x * GRID_SIZE + eyeOffset, segment.y * GRID_SIZE + GRID_SIZE - eyeOffset, eyeSize, 0, Math.PI * 2);
          ctx.arc(segment.x * GRID_SIZE + GRID_SIZE - eyeOffset, segment.y * GRID_SIZE + GRID_SIZE - eyeOffset, eyeSize, 0, Math.PI * 2);
          ctx.fill();
        }
      }
    });
  }

  function update() {
    direction = nextDirection;

    const head = { x: snake[0].x + direction.x, y: snake[0].y + direction.y };

    // Check wall collision
    if (head.x < 0 || head.x >= CANVAS_SIZE / GRID_SIZE || head.y < 0 || head.y >= CANVAS_SIZE / GRID_SIZE) {
      gameOver();
      return;
    }

    // Check self collision
    if (snake.some(seg => seg.x === head.x && seg.y === head.y)) {
      gameOver();
      return;
    }

    snake.unshift(head);

    // Check food collision
    if (head.x === food.x && head.y === food.y) {
      score += 10;
      scoreEl.textContent = score.toString();
      spawnFood();

      // Speed up slightly
      if (gameSpeed > 50) {
        gameSpeed -= 2;
      }
    } else {
      snake.pop();
    }
  }

  function gameOver() {
    if (gameLoop) {
      clearInterval(gameLoop);
      gameLoop = null;
    }

    if (score > highScore) {
      highScore = score;
      localStorage.setItem('snake-high-score', highScore.toString());
      highScoreEl.textContent = highScore.toString();
    }

    finalScoreEl.textContent = score.toString();
    gameOverOverlay.style.display = 'flex';
  }

  function startGame() {
    overlay.style.display = 'none';
    gameOverOverlay.style.display = 'none';
    initGame();
    draw();

    gameLoop = setInterval(() => {
      update();
      draw();
    }, gameSpeed);

    // Update game speed dynamically
    const speedInterval = setInterval(() => {
      if (!gameLoop) {
        clearInterval(speedInterval);
        return;
      }
      clearInterval(gameLoop);
      gameLoop = setInterval(() => {
        update();
        draw();
      }, gameSpeed);
    }, 1000);
  }

  // Keyboard controls
  document.addEventListener('keydown', (e) => {
    if (!gameLoop) return;

    switch (e.key) {
      case 'ArrowUp':
      case 'w':
      case 'W':
        if (direction.y !== 1) nextDirection = { x: 0, y: -1 };
        e.preventDefault();
        break;
      case 'ArrowDown':
      case 's':
      case 'S':
        if (direction.y !== -1) nextDirection = { x: 0, y: 1 };
        e.preventDefault();
        break;
      case 'ArrowLeft':
      case 'a':
      case 'A':
        if (direction.x !== 1) nextDirection = { x: -1, y: 0 };
        e.preventDefault();
        break;
      case 'ArrowRight':
      case 'd':
      case 'D':
        if (direction.x !== -1) nextDirection = { x: 1, y: 0 };
        e.preventDefault();
        break;
    }
  });

  // Mobile controls
  document.querySelectorAll('.control-btn').forEach(btn => {
    btn.addEventListener('click', (e) => {
      if (!gameLoop) return;
      const dir = (e.target as HTMLElement).dataset.dir;

      switch (dir) {
        case 'up':
          if (direction.y !== 1) nextDirection = { x: 0, y: -1 };
          break;
        case 'down':
          if (direction.y !== -1) nextDirection = { x: 0, y: 1 };
          break;
        case 'left':
          if (direction.x !== 1) nextDirection = { x: -1, y: 0 };
          break;
        case 'right':
          if (direction.x !== -1) nextDirection = { x: 1, y: 0 };
          break;
      }
    });
  });

  // Touch controls (swipe)
  let touchStartX = 0;
  let touchStartY = 0;

  canvas.addEventListener('touchstart', (e) => {
    touchStartX = e.touches[0].clientX;
    touchStartY = e.touches[0].clientY;
  });

  canvas.addEventListener('touchend', (e) => {
    if (!gameLoop) return;

    const touchEndX = e.changedTouches[0].clientX;
    const touchEndY = e.changedTouches[0].clientY;

    const dx = touchEndX - touchStartX;
    const dy = touchEndY - touchStartY;

    if (Math.abs(dx) > Math.abs(dy)) {
      if (dx > 0 && direction.x !== -1) {
        nextDirection = { x: 1, y: 0 };
      } else if (dx < 0 && direction.x !== 1) {
        nextDirection = { x: -1, y: 0 };
      }
    } else {
      if (dy > 0 && direction.y !== -1) {
        nextDirection = { x: 0, y: 1 };
      } else if (dy < 0 && direction.y !== 1) {
        nextDirection = { x: 0, y: -1 };
      }
    }
  });

  startBtn.addEventListener('click', startGame);
  restartBtn.addEventListener('click', startGame);

  // Initial draw
  initGame();
  draw();
</script>

<style>
  .snake-section {
    min-height: calc(100vh - var(--nav-height) - 200px);
    padding: var(--space-2xl) 0;
  }

  .back-link {
    display: inline-block;
    margin-bottom: var(--space-xl);
    color: var(--color-text-muted);
    transition: color 0.2s ease;
  }

  .back-link:hover {
    color: var(--color-accent);
  }

  .game-container {
    max-width: 450px;
    margin: 0 auto;
  }

  .game-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: var(--space-lg);
    flex-wrap: wrap;
    gap: var(--space-md);
  }

  .game-header h1 {
    font-size: 1.75rem;
    display: flex;
    align-items: center;
    gap: var(--space-sm);
  }

  .snake-emoji {
    animation: wiggle 1s ease-in-out infinite;
  }

  @keyframes wiggle {
    0%, 100% { transform: rotate(-5deg); }
    50% { transform: rotate(5deg); }
  }

  .scores {
    display: flex;
    gap: var(--space-lg);
  }

  .score-item {
    text-align: center;
  }

  .score-label {
    display: block;
    font-size: 0.75rem;
    color: var(--color-text-muted);
    text-transform: uppercase;
    letter-spacing: 0.05em;
  }

  .score-value {
    font-size: 1.5rem;
    font-weight: 700;
    color: #22c55e;
  }

  .game-area {
    position: relative;
    background: var(--color-bg-secondary);
    border-radius: 1rem;
    overflow: hidden;
    border: 2px solid var(--color-border);
  }

  #game-canvas {
    display: block;
    width: 100%;
    height: auto;
    aspect-ratio: 1;
  }

  .game-overlay {
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    display: flex;
    align-items: center;
    justify-content: center;
    background: rgba(0, 0, 0, 0.8);
    backdrop-filter: blur(4px);
  }

  .overlay-content {
    text-align: center;
    padding: var(--space-xl);
  }

  .play-icon {
    font-size: 4rem;
    display: block;
    margin-bottom: var(--space-lg);
    color: #22c55e;
  }

  .game-over-emoji {
    font-size: 4rem;
    display: block;
    margin-bottom: var(--space-md);
  }

  .game-over h2 {
    font-size: 2rem;
    color: #ef4444;
    margin-bottom: var(--space-md);
  }

  .final-score {
    font-size: 1.25rem;
    margin-bottom: var(--space-xl);
  }

  .btn-large {
    padding: var(--space-md) var(--space-2xl);
    font-size: 1.1rem;
  }

  .mobile-controls {
    display: none;
    flex-direction: column;
    align-items: center;
    gap: var(--space-sm);
    margin-top: var(--space-xl);
  }

  .control-row {
    display: flex;
    gap: var(--space-sm);
  }

  .control-btn {
    width: 60px;
    height: 60px;
    font-size: 1.5rem;
    background: var(--color-bg-secondary);
    border: 2px solid var(--color-border);
    border-radius: 0.75rem;
    color: var(--color-text);
    cursor: pointer;
    transition: all 0.2s ease;
  }

  .control-btn:hover,
  .control-btn:active {
    border-color: #22c55e;
    background: rgba(34, 197, 94, 0.1);
  }

  @media (max-width: 600px) {
    .mobile-controls {
      display: flex;
    }

    .game-header {
      justify-content: center;
      text-align: center;
    }

    .game-header h1 {
      width: 100%;
      justify-content: center;
    }
  }
</style>
